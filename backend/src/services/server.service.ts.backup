/**
 * @license MIT
 * Â© 2025 DomoForge (https://domoforge.com)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND.
 */

import { exec, spawn } from 'child_process';
import { promisify } from 'util';
import { config } from '../config/env';
import * as fs from 'fs/promises';
import * as path from 'path';
import { createReadStream, createWriteStream } from 'fs';
import { createGzip } from 'zlib';
import archiver from 'archiver';
import { getActiveInstance } from './instances.service';

const execPromise = promisify(exec);

/**
 * Server Control Service
 * Handles all server operations without bash script dependencies
 */

/**
 * Start the Project Zomboid server (active instance)
 */
export const startServer = async (): Promise<string> => {
  try {
    const activeInstance = await getActiveInstance();
    if (!activeInstance) {
      throw new Error('No active instance configured');
    }

    const { stdout, stderr } = await execPromise(`sudo systemctl start ${activeInstance.serviceName}`);
    
    // Wait a few seconds to check if it actually started
    await new Promise(resolve => setTimeout(resolve, 3000));
    
    const status = await getServerStatus();
    if (!status.running) {
      throw new Error('Server failed to start');
    }
    
    return `Server ${activeInstance.name} started successfully`;
  } catch (error) {
    throw new Error(`Failed to start server: ${error instanceof Error ? error.message : error}`);
  }
};

/**
 * Stop the Project Zomboid server (active instance)
 */
export const stopServer = async (): Promise<string> => {
  try {
    const activeInstance = await getActiveInstance();
    if (!activeInstance) {
      throw new Error('No active instance configured');
    }

    const { stdout, stderr } = await execPromise(`sudo systemctl stop ${activeInstance.serviceName}`);
    
    // Wait for graceful shutdown
    await new Promise(resolve => setTimeout(resolve, 5000));
    
    return `Server ${activeInstance.name} stopped successfully`;
  } catch (error) {
    throw new Error(`Failed to stop server: ${error instanceof Error ? error.message : error}`);
  }
};

/**
 * Restart the Project Zomboid server (active instance)
 */
export const restartServer = async (): Promise<string> => {
  try {
    const activeInstance = await getActiveInstance();
    if (!activeInstance) {
      throw new Error('No active instance configured');
    }

    const { stdout, stderr } = await execPromise(`sudo systemctl restart ${activeInstance.serviceName}`);
    
    // Wait for restart
    await new Promise(resolve => setTimeout(resolve, 5000));
    
    const status = await getServerStatus();
    if (!status.running) {
      throw new Error('Server failed to restart');
    }
    
    return `Server ${activeInstance.name} restarted successfully`;
  } catch (error) {
    throw new Error(`Failed t (active instance)
 */
export const getServerStatus = async (): Promise<{
  running: boolean;
  uptime: string | null;
  pid: number | null;
  memory: string | null;
  status: string;
  instanceId?: string;
  instanceName?: string;
}> => {
  try {
    const activeInstance = await getActiveInstance();
    if (!activeInstance) {
      return {
        running: false,
        uptime: null,
        pid: null,
        memory: null,
        status: 'no-instance'
      };
    }

    // Check if systemd service is active
    const { stdout: serviceStatus } = await execPromise(`systemctl is-active ${activeInstance.serviceNam
  status: string;,
        instanceId: activeInstance.id,
        instanceName: activeInstance.name
      };
    }
    
    // Get PID from systemd (more reliable than pgrep)
    const { stdout: pidOutput } = await execPromise(`systemctl show ${activeInstance.serviceNam
    
    if (!isServiceActive) {
      return {
        running: false,
        uptime: null,
        pid: null,
        memory: null,
        status: 'stopped'
      };
    }
    
    // Get PID from systemd (more reliable than pgrep)
    const { stdout: pidOutput } = await execPromise(`systemctl show ${config.pzService} --property=MainPID --value`);
    const pid = parseInt(pidOutput.trim());
    
    if (!pid || pid === 0) {
      return {
        running: false,
        uptime: null,
        pid: null,
        memory: null,
        status: 'stopped'
      };
    }
    
    // Get process details
    const { stdout: psOutput } = await execPromise(`ps -p ${pid} -o etime=,rss= 2>/dev/null || echo ""`);
    const [uptime, rss] = psOutput.trim().split(/\s+/);
    
    const memoryMB = rss ? Math.round(parseInt(rss) / 1024) : null;
    
    return {
      running: true,
      uptime: uptime || null,
      pid,,
      instanceId: activeInstance.id,
      instanceName: activeInstance.name
      memory: memoryMB ? `${memoryMB} MB` : null,
      status: 'running'
    };
  } catch (error) {
    return {
      running: false,
      uptime: null,
      pid: null,
      memory: null,
      status: 'unknown'
    };
  }
};

/**
 * Update the Project Zomboid server via SteamCMD
 */
export const updateServer = async (): Promise<string> => {
  return new Promise((resolve, reject) => {
    const updateCommand = `${config.pzSteamcmdPath} +login anonymous +force_install_dir ${config.pzDir} +app_update 380870 validate +quit`;
    
    const process = spawn('bash', ['-c', updateCommand], {
      stdio: ['ignore', 'pipe', 'pipe']
    });
    
    let output = '';
    let error = '';
    
    process.stdout.on('data', (data) => {
      output += data.toString();
    });
    
    process.stderr.on('data', (data) => {
      error += data.toString();
    });
    
    process.on('close', (code) => {
      if (code !== 0) {
        reject(new Error(`Update failed with code ${code}: ${error}`));
      } else {
        resolve('Server updated successfully');
      }
    });
    
    process.on('error', (err) => {
      reject(new Error(`Failed to execute update: ${err.message}`));
    });
  });
};

/**
 * Create a backup of the server files
 */
export const createBackup = async (): Promise<{ 
  filename: string; 
  path: string; 
  size: number;
  timestamp: string;
}> => {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
  const backupDir = '/opt/pzserver/backups';
  const filename = `pzserver-backup-${timestamp}.zip`;
  const backupPath = path.join(backupDir, filename);
  
  try {
    // Ensure backup directory exists
    await fs.mkdir(backupDir, { recursive: true });
    
    // Create zip archive
    const output = createWriteStream(backupPath);
    const archive = archiver('zip', {
      zlib: { level: 9 } // Maximum compression
    });
    
    return new Promise((resolve, reject) => {
      output.on('close', async () => {
        const stats = await fs.stat(backupPath);
        resolve({
          filename,
          path: backupPath,
          size: stats.size,
          timestamp: new Date().toISOString()
        });
      });
      
      archive.on('error', (err: Error) => {
        reject(new Error(`Backup failed: ${err.message}`));
      });
      
      archive.pipe(output);
      
      // Add server files to archive
      const serverName = config.pzName;
      const savePath = `/home/pzadmin/Zomboid/Server/${serverName}`;
      
      // Add save files
      archive.directory(savePath, 'Saves');
      
      // Add server configuration
      archive.file(config.pzIniPath, { name: `${serverName}.ini` });
      
      // Finalize the archive
      archive.finalize();
    });
  } catch (error) {
    throw new Error(`Failed to create backup: ${error instanceof Error ? error.message : error}`);
  }
};

/**
 * List all available backups
 */
export const listBackups = async (): Promise<Array<{
  filename: string;
  path: string;
  size: number;
  sizeFormatted: string;
  created: Date;
  createdFormatted: string;
}>> => {
  const backupDir = '/opt/pzserver/backups';
  
  try {
    const files = await fs.readdir(backupDir);
    const backupFiles = files.filter(f => f.endsWith('.zip'));
    
    const backups = await Promise.all(
      backupFiles.map(async (filename) => {
        const filePath = path.join(backupDir, filename);
        const stats = await fs.stat(filePath);
        
        return {
          filename,
          path: filePath,
          size: stats.size,
          sizeFormatted: formatBytes(stats.size),
          created: stats.mtime,
          createdFormatted: stats.mtime.toISOString()
        };
      })
    );
    
    // Sort by date, newest first
    return backups.sort((a, b) => b.created.getTime() - a.created.getTime());
  } catch (error) {
    throw new Error(`Failed to list backups: ${error instanceof Error ? error.message : error}`);
  }
};

/**
 * Delete a backup file
 */
export const deleteBackup = async (filename: string): Promise<string> => {
  const backupDir = '/opt/pzserver/backups';
  const backupPath = path.join(backupDir, filename);
  
  try {
    // Validate filename to prevent directory traversal
    if (filename.includes('..') || filename.includes('/')) {
      throw new Error('Invalid filename');
    }
    
    if (!filename.endsWith('.zip')) {
      throw new Error('Only .zip files can be deleted');
    }
    
    await fs.unlink(backupPath);
    return `Backup ${filename} deleted successfully`;
  } catch (error) {
    throw new Error(`Failed to delete backup: ${error instanceof Error ? error.message : error}`);
  }
};

/**
 * Format bytes to human-readable string
 */
function formatBytes(bytes: number): string {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
}
